// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// PostHistory is an object representing the database table.
type PostHistory struct {
	Action      string      `boil:"action" json:"action" toml:"action" yaml:"action"`
	Revision    int         `boil:"revision" json:"revision" toml:"revision" yaml:"revision"`
	RevisedAt   time.Time   `boil:"revised_at" json:"revised_at" toml:"revised_at" yaml:"revised_at"`
	ID          uint        `boil:"id" json:"id" toml:"id" yaml:"id"`
	Title       null.String `boil:"title" json:"title,omitempty" toml:"title" yaml:"title,omitempty"`
	Route       string      `boil:"route" json:"route" toml:"route" yaml:"route"`
	Content     null.String `boil:"content" json:"content,omitempty" toml:"content" yaml:"content,omitempty"`
	Markdown    null.String `boil:"markdown" json:"markdown,omitempty" toml:"markdown" yaml:"markdown,omitempty"`
	HTML        null.String `boil:"html" json:"html,omitempty" toml:"html" yaml:"html,omitempty"`
	ReadTime    null.String `boil:"read_time" json:"read_time,omitempty" toml:"read_time" yaml:"read_time,omitempty"`
	CoverImage  null.String `boil:"cover_image" json:"cover_image,omitempty" toml:"cover_image" yaml:"cover_image,omitempty"`
	Status      string      `boil:"status" json:"status" toml:"status" yaml:"status"`
	PublishedAt null.Time   `boil:"published_at" json:"published_at,omitempty" toml:"published_at" yaml:"published_at,omitempty"`
	CreatedAt   time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt   time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt   null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	OwnedByID   uint        `boil:"owned_by_id" json:"owned_by_id" toml:"owned_by_id" yaml:"owned_by_id"`
	CreatedByID uint        `boil:"created_by_id" json:"created_by_id" toml:"created_by_id" yaml:"created_by_id"`
	UpdatedByID uint        `boil:"updated_by_id" json:"updated_by_id" toml:"updated_by_id" yaml:"updated_by_id"`
	DeletedByID null.Uint   `boil:"deleted_by_id" json:"deleted_by_id,omitempty" toml:"deleted_by_id" yaml:"deleted_by_id,omitempty"`

	R *postHistoryR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L postHistoryL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PostHistoryColumns = struct {
	Action      string
	Revision    string
	RevisedAt   string
	ID          string
	Title       string
	Route       string
	Content     string
	Markdown    string
	HTML        string
	ReadTime    string
	CoverImage  string
	Status      string
	PublishedAt string
	CreatedAt   string
	UpdatedAt   string
	DeletedAt   string
	OwnedByID   string
	CreatedByID string
	UpdatedByID string
	DeletedByID string
}{
	Action:      "action",
	Revision:    "revision",
	RevisedAt:   "revised_at",
	ID:          "id",
	Title:       "title",
	Route:       "route",
	Content:     "content",
	Markdown:    "markdown",
	HTML:        "html",
	ReadTime:    "read_time",
	CoverImage:  "cover_image",
	Status:      "status",
	PublishedAt: "published_at",
	CreatedAt:   "created_at",
	UpdatedAt:   "updated_at",
	DeletedAt:   "deleted_at",
	OwnedByID:   "owned_by_id",
	CreatedByID: "created_by_id",
	UpdatedByID: "updated_by_id",
	DeletedByID: "deleted_by_id",
}

// PostHistoryRels is where relationship names are stored.
var PostHistoryRels = struct {
}{}

// postHistoryR is where relationships are stored.
type postHistoryR struct {
}

// NewStruct creates a new relationship struct
func (*postHistoryR) NewStruct() *postHistoryR {
	return &postHistoryR{}
}

// postHistoryL is where Load methods for each relationship are stored.
type postHistoryL struct{}

var (
	postHistoryColumns               = []string{"action", "revision", "revised_at", "id", "title", "route", "content", "markdown", "html", "read_time", "cover_image", "status", "published_at", "created_at", "updated_at", "deleted_at", "owned_by_id", "created_by_id", "updated_by_id", "deleted_by_id"}
	postHistoryColumnsWithoutDefault = []string{"revision", "id", "title", "route", "content", "markdown", "html", "read_time", "cover_image", "published_at", "deleted_at", "owned_by_id", "created_by_id", "updated_by_id", "deleted_by_id"}
	postHistoryColumnsWithDefault    = []string{"action", "revised_at", "status", "created_at", "updated_at"}
	postHistoryPrimaryKeyColumns     = []string{"id", "revision"}
)

type (
	// PostHistorySlice is an alias for a slice of pointers to PostHistory.
	// This should generally be used opposed to []PostHistory.
	PostHistorySlice []*PostHistory
	// PostHistoryHook is the signature for custom PostHistory hook methods
	PostHistoryHook func(context.Context, boil.ContextExecutor, *PostHistory) error

	postHistoryQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	postHistoryType                 = reflect.TypeOf(&PostHistory{})
	postHistoryMapping              = queries.MakeStructMapping(postHistoryType)
	postHistoryPrimaryKeyMapping, _ = queries.BindMapping(postHistoryType, postHistoryMapping, postHistoryPrimaryKeyColumns)
	postHistoryInsertCacheMut       sync.RWMutex
	postHistoryInsertCache          = make(map[string]insertCache)
	postHistoryUpdateCacheMut       sync.RWMutex
	postHistoryUpdateCache          = make(map[string]updateCache)
	postHistoryUpsertCacheMut       sync.RWMutex
	postHistoryUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
)

var postHistoryBeforeInsertHooks []PostHistoryHook
var postHistoryBeforeUpdateHooks []PostHistoryHook
var postHistoryBeforeDeleteHooks []PostHistoryHook
var postHistoryBeforeUpsertHooks []PostHistoryHook

var postHistoryAfterInsertHooks []PostHistoryHook
var postHistoryAfterSelectHooks []PostHistoryHook
var postHistoryAfterUpdateHooks []PostHistoryHook
var postHistoryAfterDeleteHooks []PostHistoryHook
var postHistoryAfterUpsertHooks []PostHistoryHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *PostHistory) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range postHistoryBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *PostHistory) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range postHistoryBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *PostHistory) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range postHistoryBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *PostHistory) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range postHistoryBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *PostHistory) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range postHistoryAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *PostHistory) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range postHistoryAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *PostHistory) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range postHistoryAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *PostHistory) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range postHistoryAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *PostHistory) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range postHistoryAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPostHistoryHook registers your hook function for all future operations.
func AddPostHistoryHook(hookPoint boil.HookPoint, postHistoryHook PostHistoryHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		postHistoryBeforeInsertHooks = append(postHistoryBeforeInsertHooks, postHistoryHook)
	case boil.BeforeUpdateHook:
		postHistoryBeforeUpdateHooks = append(postHistoryBeforeUpdateHooks, postHistoryHook)
	case boil.BeforeDeleteHook:
		postHistoryBeforeDeleteHooks = append(postHistoryBeforeDeleteHooks, postHistoryHook)
	case boil.BeforeUpsertHook:
		postHistoryBeforeUpsertHooks = append(postHistoryBeforeUpsertHooks, postHistoryHook)
	case boil.AfterInsertHook:
		postHistoryAfterInsertHooks = append(postHistoryAfterInsertHooks, postHistoryHook)
	case boil.AfterSelectHook:
		postHistoryAfterSelectHooks = append(postHistoryAfterSelectHooks, postHistoryHook)
	case boil.AfterUpdateHook:
		postHistoryAfterUpdateHooks = append(postHistoryAfterUpdateHooks, postHistoryHook)
	case boil.AfterDeleteHook:
		postHistoryAfterDeleteHooks = append(postHistoryAfterDeleteHooks, postHistoryHook)
	case boil.AfterUpsertHook:
		postHistoryAfterUpsertHooks = append(postHistoryAfterUpsertHooks, postHistoryHook)
	}
}

// One returns a single postHistory record from the query.
func (q postHistoryQuery) One(ctx context.Context, exec boil.ContextExecutor) (*PostHistory, error) {
	o := &PostHistory{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for post_history")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all PostHistory records from the query.
func (q postHistoryQuery) All(ctx context.Context, exec boil.ContextExecutor) (PostHistorySlice, error) {
	var o []*PostHistory

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to PostHistory slice")
	}

	if len(postHistoryAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all PostHistory records in the query.
func (q postHistoryQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count post_history rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q postHistoryQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if post_history exists")
	}

	return count > 0, nil
}

// PostHistories retrieves all the records using an executor.
func PostHistories(mods ...qm.QueryMod) postHistoryQuery {
	mods = append(mods, qm.From("`post_history`"))
	return postHistoryQuery{NewQuery(mods...)}
}

// FindPostHistory retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPostHistory(ctx context.Context, exec boil.ContextExecutor, iD uint, revision int, selectCols ...string) (*PostHistory, error) {
	postHistoryObj := &PostHistory{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `post_history` where `id`=? AND `revision`=?", sel,
	)

	q := queries.Raw(query, iD, revision)

	err := q.Bind(ctx, exec, postHistoryObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from post_history")
	}

	return postHistoryObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PostHistory) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no post_history provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(postHistoryColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	postHistoryInsertCacheMut.RLock()
	cache, cached := postHistoryInsertCache[key]
	postHistoryInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			postHistoryColumns,
			postHistoryColumnsWithDefault,
			postHistoryColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(postHistoryType, postHistoryMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(postHistoryType, postHistoryMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `post_history` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `post_history` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `post_history` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, postHistoryPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into post_history")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
		o.Revision,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for post_history")
	}

CacheNoHooks:
	if !cached {
		postHistoryInsertCacheMut.Lock()
		postHistoryInsertCache[key] = cache
		postHistoryInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the PostHistory.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *PostHistory) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	postHistoryUpdateCacheMut.RLock()
	cache, cached := postHistoryUpdateCache[key]
	postHistoryUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			postHistoryColumns,
			postHistoryPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update post_history, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `post_history` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, postHistoryPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(postHistoryType, postHistoryMapping, append(wl, postHistoryPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update post_history row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for post_history")
	}

	if !cached {
		postHistoryUpdateCacheMut.Lock()
		postHistoryUpdateCache[key] = cache
		postHistoryUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q postHistoryQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for post_history")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for post_history")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PostHistorySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), postHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `post_history` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, postHistoryPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in postHistory slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all postHistory")
	}
	return rowsAff, nil
}

var mySQLPostHistoryUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PostHistory) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no post_history provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	o.UpdatedAt = currTime

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(postHistoryColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPostHistoryUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	postHistoryUpsertCacheMut.RLock()
	cache, cached := postHistoryUpsertCache[key]
	postHistoryUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			postHistoryColumns,
			postHistoryColumnsWithDefault,
			postHistoryColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			postHistoryColumns,
			postHistoryPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert post_history, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "post_history", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `post_history` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(postHistoryType, postHistoryMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(postHistoryType, postHistoryMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for post_history")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(postHistoryType, postHistoryMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for post_history")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for post_history")
	}

CacheNoHooks:
	if !cached {
		postHistoryUpsertCacheMut.Lock()
		postHistoryUpsertCache[key] = cache
		postHistoryUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single PostHistory record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *PostHistory) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no PostHistory provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), postHistoryPrimaryKeyMapping)
	sql := "DELETE FROM `post_history` WHERE `id`=? AND `revision`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from post_history")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for post_history")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q postHistoryQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no postHistoryQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from post_history")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for post_history")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PostHistorySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no PostHistory slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(postHistoryBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), postHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `post_history` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, postHistoryPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from postHistory slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for post_history")
	}

	if len(postHistoryAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *PostHistory) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPostHistory(ctx, exec, o.ID, o.Revision)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PostHistorySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PostHistorySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), postHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `post_history`.* FROM `post_history` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, postHistoryPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PostHistorySlice")
	}

	*o = slice

	return nil
}

// PostHistoryExists checks if the PostHistory row exists.
func PostHistoryExists(ctx context.Context, exec boil.ContextExecutor, iD uint, revision int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `post_history` where `id`=? AND `revision`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD, revision)
	}

	row := exec.QueryRowContext(ctx, sql, iD, revision)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if post_history exists")
	}

	return exists, nil
}
